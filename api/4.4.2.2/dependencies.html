<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>rpm: Dependencies</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.2 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<h1><a class="anchor" name="dependencies">Dependencies</a></h1>Dependencies provide a way for a package builder to require other packages or capabilities to be installed before or simultaneously with one another. These can be used to require a python interpretor for a python based application for example. RPM ensures dependencies are satisfied whenever packages are installed, erased, or upgraded.<p>
To require the packages python and perl, use:<p>
<div class="fragment"><pre class="fragment">
	Requires: python perl
</pre></div><p>
in the spec file. Note that "Requires python, perl" would work as well. If you needed to have a very recent version of python but any version of perl,<p>
<div class="fragment"><pre class="fragment">
	Requires: python &gt;= 1.3, perl
</pre></div><p>
would do the trick. Again, the ',' in the line is optional. Instead of '&gt;=', you may also use '&lt;', '&gt;', '&lt;=', or '='. Spaces are required around the numeric operator to separate the operator from the package <a class="el" href="structname.html">name</a>.<p>
The full syntax for specifying a dependency on an epoch, version and release is <div class="fragment"><pre class="fragment">
	[epoch:]version[-release]
</pre></div> where <div class="fragment"><pre class="fragment">
	epoch	(optional) number, with assumed default of 0 if not supplied
	version	(required) can contain any character except '-'
	release	(optional) can contain any character except '-'
</pre></div><p>
For example,<p>
<div class="fragment"><pre class="fragment">
	Requires: perl &gt;= 9:5.00502-3
</pre></div><p>
specifies<p>
<div class="fragment"><pre class="fragment">
	epoch=9
	version=5.00502
	release=3
</pre></div><p>
The epoch (if present) is a monotonically increasing integer, neither the version or the release can contain the '-' hyphen character, and the dependency parser does not permit white space within a definition. Unspecified epoch and releases are assumed to be zero, and are interpreted as "providing all" or "requiring any" value.<p>
The release tag is usually incremented every time a package is rebuilt for any reason, even if the source code does not change. For example, changes to the specfile, compiler(s) used to build the package, and/or dependency changes should all be tracked by incrementing the release. The version number, on the other hand, is usually set by the developer or upstream maintainer, and should not be casually modified by the packager.<p>
Version numbering should be kept simple so that it is easy to determine the version ordering for any set of packages. If the packager needs to separate a release from all other releases that came before it, then the epoch, the most significant part of package ordering, can be changed.<p>
The algorithm that RPM uses to determine the version ordering of packages is simple and developers are encouraged not to rely on the details of its working. Developers should keep their numbering scheme simple so any reasonable ordering algorithm would work. The version comparison algorithm is in the routine <a class="el" href="rpmlib_8h.html#86c8c7c0f690d9dfd43ddb9149f7a449" title="Segmented string compare for version and/or release.">rpmvercmp()</a> and it is just a segmented strcmp(3). First, the boundaries of the segments are found using isdigit(3)/isalpha(3). Each segment is then compared in order with the right most segment being the least significant. The alphabetical portions are compared using a lexical graphical ascii ordering, the digit segments strip leading zeroes and compare the strlen before doing a strcmp. If both numerical strings are equal, the longer string is larger. Notice that the algorithm has no knowledge of decimal fractions, and perl-5.6 is "older" than perl-5.00503 because the number 6 is less than the number 503.<p>
The concept of "newer" used by rpm to determine when a package should be upgraded can be broken if version format changes oddly, such as when the version segments cannot be meaningfully compared.<p>
Example of a bad format change: 2.1.7Ax to 19980531 <div class="fragment"><pre class="fragment">
  The date may be the older version, but it is numerically greater
  2 so it is considered newer :(
</pre></div><p>
Example of a bad increment: 2.1.7a to 2.1.7A <div class="fragment"><pre class="fragment">
  The 'a' (ASCII 97) is compared against 'A' (ASCII 65), making 2.1.7a
  the newer version.
</pre></div><p>
Stick to major.minor.patchlevel using numbers for each if you can. Keeps life simple :-)<p>
If a Requires: line needs to include an epoch in the comparison, then the line should be written like<p>
<div class="fragment"><pre class="fragment">
	Requires: somepackage = 23:version
</pre></div><p>
You can't continue a "Requires: " line. If you have multiple "Requires: " lines then the package requires all packages mentioned on all of the lines to be installed.<p>
Prereqs are different from requires only in that a PreReq is guaranteed to be installed before the package that contains the PreReq. PreReq's are used only to order packages, otherwise PreReq's are exactly the same as a Requires: dependency.<p>
Sometimes you need to make sure the system your package is being installed on has a package which provides a certain capability, even though you don't care what specific package provides it. For example, sendmail won't work properly unless a local delivery agent (lda) is present. You can ensure that one is installed like this:<p>
<div class="fragment"><pre class="fragment">
	Requires: lda
</pre></div><p>
This will match either a package called lda (as mentioned above), or any package which contains:<p>
<div class="fragment"><pre class="fragment">
	Provides: lda
</pre></div><p>
in its .spec file. No version numbers may be used with virtual packages.<p>
Virtual packages are often used to supply file dependencies such as /bin/sh on machines that are only partly managed by rpm. A virtual package with <div class="fragment"><pre class="fragment">
	Provides: /bin/sh
</pre></div> differs from a package that has /bin/sh in the files list in that the package can be safely removed without removing /bin/sh.<p>
To reduce the amount of work required by the package builder, RPM scans the file list of a package when it is being built. Any files in the file list which require shared libraries to work (as determined by ldd) cause that package to require the shared library.<p>
For example, if your package contains /bin/vi, RPM will add dependencies for both libtermcap.so.2 and libc.so.5. These are treated as virtual packages, so no version numbers are used.<p>
A similar process allows RPM to add Provides information automatically. Any shared library in the file list is examined for its soname (the part of the <a class="el" href="structname.html">name</a> which must match for two shared libraries to be considered equivalent) and that soname is automatically provided by the package. For example, the libc-5.3.12 package has provides information added for libm.so.5 and libc.so.5. We expect this automatic dependency generation to eliminate the need for most packages to use explicit Requires: lines.<p>
The automatic dependency programs are found via macro expansion. Thus sites can very the amount of dependency processing that are performed locally, by changing the executable/script which is run. Dependency processing can even be changed on a per-package basis if the macros are defined in the spec file. To allow for maximum configurability the dependency programs are shell scripts which can be duplicated and edited for site specific needs.<p>
The macros: __find_provides, __find_prereq, __find_requires, __find_conflicts, __find_obsoletes, if they exist, are expanded to the <a class="el" href="structname.html">name</a> of a program to exec. For each package, the program receives the glob'ed files manifest on stdin and returns dependencies on stdout. The discovered dependencies are parsed exactly as if they were found after<p>
<div class="fragment"><pre class="fragment">
	Provides:
	PreReq:
	Requires:
	Conflicts:
	Obsoletes:
</pre></div> tokens in a spec file (i.e. the same parser is used), so items look like (comments added) <div class="fragment"><pre class="fragment">
	/bin/sh			# file existence
	libc.so.6		# soname existence
	foo &lt;= 1:2.3-4		# versioned package
	perl5(Apache) &lt;= 1.2	# versioned namespace
</pre></div><p>
The default rpm configuration has only __find_provides /usr/lib/rpm/find-provides __find_requires /usr/lib/rpm/find-requires which can be overridden (or even undefined) within a spec file.<p>
Modules for interpreted languages like perl and tcl impose additional dependency requirements on packages. A script written for an interpreter often requires language specific modules to be installed in order to execute correctly. In order to automatically detect language specific modules, each interpreter may have its own find-provides and find-requires. To prevent module <a class="el" href="structname.html">name</a> collisions between interpreters, module <a class="el" href="structnames.html">names</a> are enclosed within parentheses and a conventional interpreter specific identifier is prepended:<p>
<div class="fragment"><pre class="fragment">
  Provides: perl(MIME-Base64), perl(Mail-Header)-1-09

  Requires: perl(Carp), perl(IO-Wrap) = 4.5
</pre></div><p>
The output of a per-interpreter find-requires (notice in this example the first requirement is a package and the rest are language specific modules)<p>
<div class="fragment"><pre class="fragment">
	Mail-Header &gt;= 1.01
	perl(Carp) &gt;= 3.2
	perl(IO-Wrap) == 4.5 or perl(IO-Wrap)-4.5
</pre></div><p>
the output from find-provides is <div class="fragment"><pre class="fragment">
	Foo-0.9
	perl(Widget)-0-1
</pre></div><p>
The per-interpreter automatic module detectors will normally be located in <div class="fragment"><pre class="fragment">
	/usr/lib/rpm/{perl,tcl}/find-{provides,requires}
with appropriate per-interpreter hooks into
\verbatim
	/usr/lib/rpm/find-{provides,requires}
</pre></div><p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000015">Todo:</a></b></dt><dd>per-interpreter dependency generators are not located in subdirectories.</dd></dl>
Notice that shell dependencies will require that all post et al scriptlets be processed by the find-requires. Since a shell script depends on all the programs which it runs.<p>
For the most part, dependencies should be transparent to the user. However, a few things will change.<p>
First, when packages are added or upgraded, all of their dependencies must be satisfied. If they are not, an error message like this appears:<p>
<div class="fragment"><pre class="fragment">
    failed dependencies:
	    libICE.so.6  is needed by somepackage-2.11-1
	    libSM.so.6  is needed by somepackage-2.11-1
	    libc.so.5  is needed by somepackage-2.11-1
</pre></div><p>
Similarly, when packages are removed, a check is made to ensure that no installed packages will have their dependency conditions break due to the packages being removed. If you wish to turn off dependency checking for a particular command, use the --nodeps flag.<p>
While conflicts were implemented in earlier versions of RPM they never worked properly until RPM 2.3.4 (well, we hope they work properly now anyway).<p>
Conflicts allow a package to say it won't work with another package (or virtual package) installed on the system. For example, qmail doesn't work (w/o custom setup) on machines with sendmail installed. The qmail spec file may codify this with a line like:<p>
<div class="fragment"><pre class="fragment">
	Conflicts: sendmail
</pre></div><p>
The syntax of the "Conflicts" tag is identical to the syntax of the Requires tag and conflict checking may be overridden by using the --nodeps flag.<p>
Two new query information selection options are now available. The first, --provides, prints a list of all of the capabilities a package provides. The second, --requires, shows the other packages that a package requires to be installed, along with any version number checking.<p>
There are also two new ways to search for packages. Running a query with --whatrequires  queries all of the packages that require . Similarly, running --whatprovides  queries all of the packages that provide the  virtual package. Note that querying for package that provides "python" will not return anything, as python is a package, not a virtual package.<p>
As of RPM 2.2.2, -V (aka --verify) verifies package dependencies by default. You can tell rpm to ignore dependencies during system verification with the --nodeps. If you want RPM to verify just dependencies and not file attributes (including file existence), use the --nofiles flag. Note that "rpm -Va --nofiles --nodeps" will not verify anything at all, nor generate an error message.<p>
It is quite common to need to branch a set of sources in version control. It is not so obvious how those branches should be represented in the package version numbers. Here is one solution.<p>
You have a bag of features that are injected into a package in a non-ordered fashion, and you want to have the package name-version-release be able to:<p>
<div class="fragment"><pre class="fragment">
	1) identify the "root version" of the source code.
	2) identify the handful of features that are in that
	   branch of the package.
	3) preserve sufficient ordering so that packages upgrade
	   without the use of --oldpackage.
</pre></div><p>
A simple (but possibly not adequate) scheme to achieve this is:<p>
<div class="fragment"><pre class="fragment">
	Name: foo
	Version: &lt;the "root version" of the source code&gt;
	Release: &lt;release instance&gt;.&lt;branch&gt;
</pre></div><p>
where the release instance is something like YYYMMMDD or some linear <a class="el" href="unionrecord.html">record</a> of the number of builds with the current tar file, it is used to preserve ordering when necessary.<p>
Another alternative scheme might be:<p>
<div class="fragment"><pre class="fragment">
	Name: foo
	Epoch: &lt;branch&gt;
	Version: &lt;the branch specific version of the code&gt;
	Release: &lt;release instance&gt;
</pre></div><p>
The following dependencies are available at build time. These are similar to the install time version but these apply only during package creation and are specified in the specfile not in the binary package.<p>
<div class="fragment"><pre class="fragment">
	BuildRequires:
	BuildConflicts:
	BuildPreReq:
</pre></div> <hr size="1"><address style="text-align: right;"><small>Generated on Fri Oct 12 08:44:57 2007 for rpm by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.2 </small></address>
</body>
</html>
